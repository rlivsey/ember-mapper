{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Ember-mapper","body":"# EmberMapper\r\n\r\nA complex solution to a simple problem.\r\n\r\n## Why not Ember Data\r\n\r\nEmber Data is more than likely fine for your purposes, you probably don't want\r\nto use this.\r\n\r\nAt the time of writing Ember Data didn't match my needs. It probably will do in future, but I'm impatient.\r\n\r\nI wanted a bit more control over the URLs used and how the data is serialized/deserialized,\r\nI needed composed objects, setting properties without marking the object as dirty etc...\r\n\r\nThis doesn't handle dirty tracking and many of the other nice things you get with Ember Data,\r\nit assumes you know what you want to save and when.\r\n\r\nIt basically just provides serializing to / from JSON with an identity map and leaves most of the rest to you.\r\n\r\n## TODO\r\n\r\n* Tests for stores\r\n* Validation\r\n* Non-embedded associations (foreign key support, haven't needed it yet myself)\r\n* Use state machines for lifecycles instead of properties\r\n\r\n## Quick Overview\r\n\r\n    App.Person = Ember.Object.extend({})\r\n\r\n    App.personSchema = EmberMapper.Schema.create({\r\n      modelClass: App.Person\r\n      mappings: {\r\n        firstName: \"string\",\r\n        lastName: \"string\"\r\n      }\r\n    })\r\n\r\n    App.peopleStore = EmberMapper.Store.create({\r\n      schema: App.PersonSchema\r\n    })\r\n\r\n    people = App.peopleStore.findMany({name: \"Bob\"})\r\n\r\n    person = App.peopleStore.find(123)\r\n    person.set(\"firstName\", \"Terry\")\r\n\r\n    App.peopleStore.updateRecord(person)\r\n\r\n## Models\r\n\r\nYour models are 'plain old ember objects', they don't know anything about the\r\ndata store and don't need to inherit / include anything.\r\n\r\n    App.Person = Ember.Object.extend()\r\n\r\nIn order for the identity map to work, it needs to set a property `_im_cid` on\r\nyour model instances.\r\n\r\nWhen saving / loading etc... it will set some flags on your model:\r\n\r\n    * isLoading\r\n    * isSaving\r\n    * isUpdating\r\n    * isCreating\r\n    * isDeleting\r\n    * isDeleted\r\n\r\n## Schema\r\n\r\nA schema uses serializers to convert a model to / from JSON.\r\n\r\nThey are identity map aware so deserializing will update the identity map for the schema.\r\n\r\n    App.PersonSchema = EmberMapper.Schema.extend({\r\n      modelClass: \"App.Person\",\r\n\r\n      mappings: {\r\n        firstName: EmberMapper.Schema.attr(\"string\"),         // use the string type\r\n        lastName: \"string\",                                   // or to save typing, just the name\r\n        account: EmberMapper.Schema.one(\"App.AccountSchema\"), // map to another schema for embedded documents\r\n        tasks: EmberMapper.Schema.many(\"App.TaskSchema\")      // or arrays of embedded documents\r\n      },\r\n\r\n      // you can include one-way mappings from the JSON\r\n      // which is handy for counts etc... which you don't want to save back\r\n      fromMappings: {\r\n        numProjects: EmberMapper.Schema.attr(\"number\"), // this won't be serialized to JSON\r\n        createdAt: \"timestamp\"\r\n      },\r\n\r\n      // and to JSON in occasions where you want to send something extra\r\n      toMappings: {\r\n        sendInvite: EmberMapper.Schema.attr(\"boolean\") // this won't get deserialized from JSON\r\n      }\r\n    })\r\n\r\n### Model Class\r\n\r\nMost of the time your schema is for one specific model type.\r\n\r\nSometimes you might want to implement polymorphism / STI where you create different kinds of models\r\nbased on the JSON which is returned.\r\n\r\nSimply override `modelClassForJSON` to do your bidding.\r\n\r\n    modelClassForJSON: function(json) {\r\n      if (json.type == \"car\") {\r\n        return App.Car;\r\n      } else {\r\n        return App.Bus;\r\n      }\r\n    }\r\n\r\n### Custom Attribute Serializing\r\n\r\nAn attribute is simply something with a `from` and a `to` method.\r\n\r\n* `from` takes JSON and turns it into an object.\r\n* `to` takes an object and turns it into JSON.\r\n\r\nHow it does that is up to you.\r\n\r\nAny attribute on `EmberMapper.Schema.transforms` is available to be used for serializing / deserializing.\r\n\r\n    EmberMapper.Schema.transforms.timestamp = {\r\n      from: function (serialized) { return new Date(serialized * 1000); },\r\n      to: function (deserialized) { return deserialized.getTime() / 1000; }\r\n    }\r\n\r\n### JSON Key Naming Conventions\r\n\r\nThe default naming convention is to camelcase your JSON keys\r\n\r\n    first_name -> firstName\r\n\r\nYou can override this on a Schema by overriding `propertyToKeyName`\r\n\r\n    propertyNameToKey: function(key) {\r\n      return Ember.String.underscore(key);\r\n    }\r\n\r\nIf you want to change it for all Schemas, reopen `EmberMapper.Schema`\r\n\r\n    EmberMapper.Schema.reopen({\r\n      propertyNameToKey: function(key) {\r\n        return key.toUpperCase();\r\n      }\r\n    })\r\n\r\n## Stores\r\n\r\nA Store takes a Schema and loads/saves it to the intertubes.\r\n\r\n    peopleStore = EmberMapper.Store.create({\r\n      schema: peopleSchema\r\n    })\r\n\r\nRequests return immediately and are loaded when data arrives.\r\n\r\nThis returns a Person right away with its ID set to 123, it will have `isLoading` set to true.\r\n\r\n    peopleStore.find(123)\r\n\r\nThis returns a RecordArray with a content of `[]`, again `isLoading` will be true until data arrives.\r\n\r\n    peopleStore.findMany({\r\n      named: \"bob\"\r\n    })\r\n\r\n\r\n### URLs\r\n\r\nYou should set a base URL for the store:\r\n\r\n    EmberMapper.Store.create({\r\n      url: \"/api/v1/people\"\r\n    })\r\n\r\nThis is then built on for all requests, for example `updateRecord` will use the url with the record ID appended.\r\n\r\nIf you want to customize a specific URL, override it and do what you like:\r\n\r\n    EmberMapper.Store.create({\r\n      deleteRecordUrl: function(record) {\r\n        return this.get(\"url\") + \"/deletification/\" + record.get(\"id\");\r\n      }\r\n    })\r\n\r\nThe `url` can be a computed property, so you make it bind to something else in your app:\r\n\r\n    EmberMapper.Store.create({\r\n      currentProjectBinding: \"App.current.project\",\r\n\r\n      url: function(){\r\n        var projectId = this.getPath(\"currentProject.id\");\r\n        return \"/projects/\"+projectId;\r\n      }.property(\"currentProject\")\r\n    })\r\n\r\n### Custom Requests\r\n\r\nYou're encouraged to write your own custom requests. Instead of your code being littered with:\r\n\r\n    peopleStore.findMany({\r\n      project_id: App.getPath(\"current.project.id\")\r\n    })\r\n\r\nYou can have:\r\n\r\n    peopleStore.inProject(App.getPath(\"current.project\"))\r\n    peopleStore.named(\"bob\")\r\n    etc...\r\n\r\nSimply add your own finder which calls the built in ones:\r\n\r\n    EmberMapper.Store.create({\r\n      named: function(name) {\r\n        return this.findMany({\r\n          name: \"bob\"\r\n        });\r\n      }\r\n    })\r\n\r\nOr if you need to do sideloading or any other custom stuff, feel free!\r\nThe xxxRequest methods return a jQuery deferred ajax object, so you can add your own callbacks.\r\n\r\nJust look at findMany / updateRecord / etc... to write your own:\r\n\r\n    EmberMapper.Store.create({\r\n      paginated: function(page) {\r\n        var records = EmberMapper.RecordArray.create();\r\n\r\n        // same as usual findMany, but with your own parameters\r\n        var ajax = this.findManyRequest(this.findManyUrl(), records, {\r\n          data: { page: page }\r\n        });\r\n\r\n        // add your own callback and do more stuff when the request completes\r\n        ajax.done(function(data){\r\n          records.set(\"pagination\", {\r\n            perPage: data.per_page\r\n          });\r\n        });\r\n\r\n        return records;\r\n      }\r\n    });\r\n\r\nIf you want to do something to every request then you can override `ajax` or one of\r\nthe `xxxRequest` methods:\r\n\r\n    EmberMapper.Store.create({\r\n      findManyRequest: function(url, records, hash) {\r\n        var ajax = this._super(url, records, hash);\r\n        ajax.error(function(){\r\n          // do stuff on error\r\n        });\r\n        return ajax;\r\n      }\r\n    });\r\n","google":"","tagline":"Like Ember Data, but not as good"}